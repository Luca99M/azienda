<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Totem â€“ Avatar 3D a prova di errore (parla e muove la bocca)</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0f14;color:#e9f0f7;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    .wrap{max-width:520px;margin:0 auto;display:grid;grid-template-rows:auto 1fr auto;min-height:100%}
    header{padding:14px 16px;display:flex;gap:10px;align-items:center}
    header h1{font-size:1.1rem;margin:0}
    .stage{display:grid;place-items:center;padding:8px}
    #view{width:320px;height:380px;background:radial-gradient(120px 140px at 50% 25%,#1a2532,#0f1620);border-radius:18px;box-shadow:0 16px 50px rgba(0,0,0,.45),inset 0 0 0 1px rgba(255,255,255,.05);position:relative}
    .stat{position:absolute;bottom:8px;left:8px;font-size:.8rem;color:#9db3c7}
    .panel{padding:12px 16px}
    .row{display:flex;gap:8px}
    textarea{flex:1;min-height:64px;background:#0e1620;color:#e9f0f7;border:1px solid rgba(255,255,255,.07);border-radius:12px;padding:10px}
    button{background:#79d14a;color:#05240e;border:none;padding:10px 12px;border-radius:12px;font-weight:700;cursor:pointer}
    button.secondary{background:#192633;color:#e9f0f7;border:1px solid rgba(255,255,255,.07)}
    .log{max-height:28vh;overflow:auto;margin-top:10px;display:flex;flex-direction:column;gap:8px}
    .msg{background:#0e1620;border:1px solid rgba(255,255,255,.06);padding:10px;border-radius:12px}
    .msg.user{border-color:rgba(121,209,74,.25)}
    footer{padding:10px 16px;color:#9db3c7;font-size:.85rem}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Avatar 3D procedurale (sempre funzionante) â€“ bocca & blink</h1>
    </header>

    <main class="stage">
      <div id="view" aria-label="viewport 3D"><div class="stat" id="stat">Pronto</div></div>
    </main>

    <section class="panel">
      <div class="row">
        <textarea id="q" placeholder="Scrivi qualcosa da far dire all'avatar (in italiano)â€¦">Ciao! Sono l'assistente della fattoria. Posso consigliarti su olio e formaggi: allergeni, conservazione, abbinamenti.</textarea>
        <button id="speak">Parla</button>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="mic" class="secondary">ðŸŽ¤ Ascolta</button>
        <button id="stop" class="secondary">â—¼ Stop</button>
      </div>
      <div class="log" id="log"></div>
    </section>

    <footer>Demo locale senza modelli esterni: testa 3D creata via codice, mascella animata a tempo con la voce (Web Speech). Nessun invio al cloud.</footer>
  </div>

  <!-- Solo THREE.js, nessun loader/model esterno -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
  // ====== SCENA BASE ======
  const view = document.getElementById('view');
  const stat = document.getElementById('stat');
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(40, 320/380, 0.1, 100);
  const renderer = new THREE.WebGLRenderer({alpha:true, antialias:true});
  renderer.setSize(320,380); renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
  renderer.setClearColor(0x000000, 0);
  view.appendChild(renderer.domElement);

  const clock = new THREE.Clock();
  scene.add(new THREE.AmbientLight(0xffffff, .6));
  const dir = new THREE.DirectionalLight(0xffffff, .9); dir.position.set(0.6,1,0.6); scene.add(dir);
  camera.position.set(0, .05, 2.1); camera.lookAt(0, .05, 0);

  // ====== AVATAR PROCEDURALE: TESTA + MASCELLA + OCCHI + PALPEBRE ======
  const group = new THREE.Group(); scene.add(group);

  // Testa (cupola superiore)
  const headGeom = new THREE.SphereGeometry(0.6, 48, 48, 0, Math.PI*2, 0, Math.PI*0.62);
  const skin = new THREE.MeshStandardMaterial({ color: 0xe9c9a5, roughness: .6, metalness: .0 });
  const head = new THREE.Mesh(headGeom, skin); head.position.y = 0.15; head.castShadow=head.receiveShadow=true; group.add(head);

  // Mascella (semi-sfera inferiore) â€“ ruota per aprire la bocca
  const jawGeom = new THREE.SphereGeometry(0.6, 48, 48, 0, Math.PI*2, Math.PI*0.5, Math.PI*0.5);
  const jaw = new THREE.Mesh(jawGeom, skin); jaw.position.y = -0.15; jaw.castShadow=true; group.add(jaw);
  // Punto di rotazione (cerniera) arretrato leggermente
  jaw.geometry.translate(0, 0.3, 0);

  // Bocca interna (scuro)
  const mouthGeom = new THREE.CapsuleGeometry(0.28, 0.06, 8, 16);
  const mouthMat = new THREE.MeshStandardMaterial({ color: 0x111418, roughness: 1 });
  const mouth = new THREE.Mesh(mouthGeom, mouthMat); mouth.position.set(0,-0.02,0.48); group.add(mouth);

  // Occhi
  const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
  const pupilMat = new THREE.MeshStandardMaterial({ color: 0x0b0f14 });
  const eyeGeom = new THREE.SphereGeometry(0.08, 24, 24);
  const pupilGeom = new THREE.SphereGeometry(0.04, 24, 24);
  const eyeL = new THREE.Mesh(eyeGeom, eyeMat); eyeL.position.set(-0.23, 0.18, 0.48); group.add(eyeL);
  const eyeR = new THREE.Mesh(eyeGeom, eyeMat); eyeR.position.set( 0.23, 0.18, 0.48); group.add(eyeR);
  const pupilL = new THREE.Mesh(pupilGeom, pupilMat); pupilL.position.set(-0.23, 0.17, 0.54); group.add(pupilL);
  const pupilR = new THREE.Mesh(pupilGeom, pupilMat); pupilR.position.set( 0.23, 0.17, 0.54); group.add(pupilR);

  // Palpebre (piani sottili che scendono a chiudere)
  const lidMat = new THREE.MeshStandardMaterial({ color: 0xe9c9a5 });
  const lidGeom = new THREE.PlaneGeometry(0.22, 0.16);
  const lidL = new THREE.Mesh(lidGeom, lidMat); lidL.position.set(-0.23, 0.24, 0.55); lidL.rotation.x = -0.35; group.add(lidL);
  const lidR = new THREE.Mesh(lidGeom, lidMat); lidR.position.set( 0.23, 0.24, 0.55); lidR.rotation.x = -0.35; group.add(lidR);
  let lidProgress = 0; // 0=aperto, 1=chiuso

  // Posizione gruppo
  group.position.y = 0.1;

  // ====== LIP-SYNC SEMPLICE & IDLE ======
  let mouthTarget=0, mouthValue=0, mouthVel=0; // 0..1 apertura
  let talking=false;

  // Blink casuale
  setInterval(()=>{
    if (talking) return; // meno blink mentre parla
    if (Math.random()<0.35){
      // chiudi
      lidProgress = 1;
      setTimeout(()=>{ lidProgress = 0; }, 120);
    }
  }, 1700);

  function animate(){
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    // micro-movimento testa
    const t = clock.elapsedTime;
    group.rotation.y = Math.sin(t*0.35)*0.06;
    group.position.y = 0.1 + Math.sin(t*0.9)*0.02;

    // easing bocca
    mouthVel += (mouthTarget - mouthValue) * 10 * dt; mouthVel *= 0.82; mouthValue += mouthVel; mouthValue=Math.max(0,Math.min(1,mouthValue));
    jaw.rotation.x = THREE.MathUtils.lerp(0, 0.6, mouthValue); // apri fino a ~34Â°

    // occhi seguono lentamente il mouse
    const k = 0.02; pupilL.position.x += (mouse.x*0.15 - pupilL.position.x)*k; pupilR.position.x += (mouse.x*0.15 - pupilR.position.x)*k;
    pupilL.position.y += (0.17 + mouse.y*0.08 - pupilL.position.y)*k; pupilR.position.y += (0.17 + mouse.y*0.08 - pupilR.position.y)*k;

    // palpebre
    const lidYOpen = 0.24, lidYClosed = 0.18;
    lidL.position.y = THREE.MathUtils.lerp(lidYOpen, lidYClosed, lidProgress);
    lidR.position.y = THREE.MathUtils.lerp(lidYOpen, lidYClosed, lidProgress);

    renderer.render(scene,camera);
  }
  animate();

  // mouse per occhi
  const mouse = {x:0,y:0};
  view.addEventListener('mousemove', (e)=>{
    const r = view.getBoundingClientRect();
    mouse.x = (e.clientX - r.left)/r.width * 2 - 1;
    mouse.y = -((e.clientY - r.top)/r.height * 2 - 1);
  });

  // ====== UI & VOCE ======
  const log = document.getElementById('log');
  function push(t,who='bot'){ const d=document.createElement('div'); d.className='msg '+(who==='user'?'user':'bot'); d.textContent=t; log.appendChild(d); log.scrollTop=log.scrollHeight; }

  const synth = window.speechSynthesis; let voice=null; function pickVoice(){ const vs=synth.getVoices(); voice = (vs.find(v=>v.lang&&v.lang.startsWith('it'))||vs[0]); }
  synth.onvoiceschanged = pickVoice; pickVoice();

  function speak(text){ if(!synth) return; synth.cancel(); const u=new SpeechSynthesisUtterance(text.replace(/[\p{Extended_Pictographic}]/gu,'')); u.lang='it-IT'; if(voice) u.voice=voice; u.rate=0.9; u.pitch=0.95; u.volume=1;
    u.onstart=()=>{ talking=true; mouthTarget=0.6; pulseStart(); };
    u.onend=()=>{ talking=false; mouthTarget=0; pulseStop(); };
    u.onboundary=(e)=>{ if(e.name==='word' || e.charIndex!==undefined){ mouthTarget=1.0; } };
    synth.speak(u);
  }
  let pulse=null; function pulseStart(){ if(pulse) return; pulse=setInterval(()=>{ mouthTarget=Math.max(mouthTarget,0.35+Math.random()*0.25); },110);} function pulseStop(){ clearInterval(pulse); pulse=null; }

  document.getElementById('speak').onclick=()=>{ const t=document.getElementById('q').value.trim(); if(!t) return; push(t,'user'); speak(t); };
  document.getElementById('stop').onclick=()=>{ try{ speechSynthesis.cancel(); mouthTarget=0; }catch{} };

  // Microfono (ASR browser)
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition; let recog=null; if(SR){ recog=new SR(); recog.lang='it-IT'; recog.continuous=false; recog.interimResults=false; }
  document.getElementById('mic').onclick=()=>{ if(!recog){ push('Il riconoscimento vocale non Ã¨ supportato in questo browser. Usa Chrome su HTTPS o localhost.'); return;} try{ recog.start(); }catch{}
    recog.onresult=(e)=>{ const t=e.results[0][0].transcript; document.getElementById('q').value=t; push(t,'user'); speak(t); };
  };
  </script>
</body>
</html>
